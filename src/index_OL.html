<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPS traces</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/openlayers/dist/ol.css" type="text/css">
    <script src="https://cdn.jsdelivr.net/npm/openlayers/dist/ol.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-color@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3"></script>

    <style>
        #map {
            height: 100vh;
            width: 100%;
        }
    </style>
</head>

<body>
    <div id="map" class="map"></div>
    <script>

        fetch('http://127.0.0.1:5500/tiled/metadata.json')
            .then(response => response.json())
            .then(metadata => {

                //const bckgs = new ol.source.OSM()
                //const bckgs = new ol.source.XYZ({ url: 'http://{a-c}.tile.stamen.com/toner/{z}/{x}/{y}.png' });
                const bckgs = new ol.source.XYZ({ url: 'https://{a-d}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png' })

                //build map
                var map = new ol.Map({
                    target: 'map',
                    layers: [new ol.layer.Tile({ source: bckgs })],
                    view: new ol.View({ center: ol.proj.fromLonLat([5.3698, 43.2965]), zoom: 13 })
                });

                //tile cache
                const cache = {}
                function getCacheData(z, x, y) {
                    if (!cache[z]) return
                    if (!cache[z][x]) return
                    return cache[z][x][y]
                }
                function insertInCache(z, x, y, data) {
                    if (!cache[z]) cache[z] = {}
                    if (!cache[z][x]) cache[z][x] = {}
                    cache[z][x][y] = data
                }

                //create vector layer
                var vectorSource = new ol.source.Vector();
                var vectorLayer = new ol.layer.Vector({
                    source: vectorSource,
                    style: function (f) {
                        const sp = f.get('speed_kmh')

                        const color = d3.interpolateSpectral(1 - sp / 200)
                        //interpolateSpectral interpolateTurbo

                        return new ol.style.Style({
                            stroke: new ol.style.Stroke({
                                color: color,
                                width: 2
                            })
                        });
                    }
                });
                map.addLayer(vectorLayer);

                //read base metadata
                const ts0 = metadata.tile_size_0, r0 = metadata.resolution_0,
                    ox = metadata.origin_x, oy = metadata.origin_y,
                    z_min = metadata.z_min, z_max = metadata.z_max

                //transform geojson geometry coordinate from tile CRS to map CRS
                function transformGeoJSONGeometryCoordinates(geometry, tile, ts, r) {
                    function transformCoordinates(coordinates) {
                        if (Array.isArray(coordinates[0])) return coordinates.map(transformCoordinates);
                        else {
                            const x = coordinates[0], y = coordinates[1]
                            return [ox + tile.x * ts + x * r, oy + tile.y * ts + y * r];
                        }
                    }
                    //if (geometry && geometry.coordinates)
                    geometry.coordinates = transformCoordinates(geometry.coordinates);
                }




                function updateLayer() {

                    //get zoom level
                    let z = Math.round(map.getView().getZoom())
                    if (z < z_min) z = z_min; else if (z > z_max) z = z_max
                    //console.log(z)

                    //compute tile size and resolution
                    const ddd = Math.pow(2, z)
                    const ts = ts0 / ddd
                    const r = r0 / ddd

                    //clear
                    vectorSource.clear();

                    //get tiles within viewshed
                    var bbox = map.getView().calculateExtent(map.getSize());
                    var tiles = getTiles(bbox, ts);

                    //handle each tile
                    tiles.forEach(tile => {

                        //try to retrieve from cache
                        const features = getCacheData(z, tile.x, tile.y)

                        if (features == "failed" || features == "loading") {
                            //do nothing
                        } else if (features) {
                            //add cached features to layer
                            vectorSource.addFeatures(features);
                        } else {
                            //mark as loading
                            insertInCache(z, tile.x, tile.y, "loading")

                            //launch request
                            fetch(`http://127.0.0.1:5500/tiled/${z}/${tile.x}/${tile.y}.geojson`)
                                .then(response => response.json())
                                .then(geojson => {

                                    //apply coordinates transformation to features
                                    geojson.features.forEach(feature => transformGeoJSONGeometryCoordinates(feature.geometry, tile, ts, r));
                                    geojson.features.forEach(feature => feature.id = Math.round(1e15 * Math.random()))

                                    //transform into OL feature
                                    var features = new ol.format.GeoJSON().readFeatures(geojson, { featureProjection: 'EPSG:3857' });

                                    //store into cache
                                    insertInCache(z, tile.x, tile.y, features)

                                    //add features to layer
                                    vectorSource.addFeatures(features);
                                })
                                .catch(error => {
                                    insertInCache(z, tile.x, tile.y, "failed")
                                    //console.error('Error fetching GeoJSON tile:', tile.x, tile.y, error)
                                });
                        }
                    });
                }

                //get tiles intersecting the viewshed
                function getTiles(bbox, ts) {

                    const [xmin, ymin, xmax, ymax] = bbox;

                    const
                        xtmin = Math.floor((xmin - ox) / ts),
                        ytmin = Math.floor((ymin - oy) / ts),
                        xtmax = Math.floor((xmax - ox) / ts),
                        ytmax = Math.floor((ymax - oy) / ts);

                    var tiles = [];
                    for (var xt = xtmin; xt <= xtmax; xt++)
                        for (var yt = ytmin; yt <= ytmax; yt++)
                            tiles.push({ x: xt, y: yt });

                    return tiles;
                }

                //trigger layer refresh on viewshed changes
                map.getView().on('change:center', updateLayer);
                map.getView().on('change:resolution', updateLayer);

                updateLayer();

            })
            .catch(error => console.error('Error fetching the JSON data:', error));
    </script>
</body>

</html>