<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPS traces</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/openlayers/dist/ol.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        #map {
            height: 100vh;
            width: 100%;
            position: fixed;
            left: 0;
            top: 0;
            overflow: hidden;
        }

        .control-container {
            position: absolute;
            top: 60px;
            left: 10px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            font-family: sans-serif;
        }
    </style>
</head>

<body>

    <div id="map" class="map"></div>

    <div class="control-container">
        <form id="layer-switcher">
            <label><input type="radio" name="style" value="default" checked>Traces</label>
            <br>
            <label><input type="radio" name="style" value="byspeed">by speed</label>
            <br>
            <label><input type="radio" name="style" value="bydate">by date</label>
        </form>
    </div>

    <script>

        fetch('http://127.0.0.1:5500/tiled/metadata.json')
            .then(response => response.json())
            .then(metadata => {

                //const bckgs = new ol.source.OSM()
                //const bckgs = new ol.source.XYZ({ url: 'http://{a-c}.tile.stamen.com/toner/{z}/{x}/{y}.png' });
                const bckgs = new ol.source.XYZ({ url: 'https://{a-d}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png' })

                //build map
                var map = new ol.Map({
                    target: 'map',
                    layers: [new ol.layer.Tile({ source: bckgs })],
                    view: new ol.View({ center: ol.proj.fromLonLat([5.3698, 43.2965]), zoom: 13 })
                });


                //radio button change event
                //document.getElementById('layer-switcher').addEventListener('change', updateStyle);

                /*//
                function updateStyle() {
                    const selectedStyle = document.querySelector('input[name="style"]:checked').value
                    console.log(selectedStyle)
                }*/

                //default style
                const styleDefaultFun = function (f) {
                    return new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: "red",
                            width: 1
                        })
                    });
                }

                //speed style
                const colorScaleSpeed = d3.scaleLinear().domain([0, 0.05, 0.4, 0.75, 0.95, 1]).range(["#4DAF4A", "#4DAF4A", "#377EB8", "#E41A1C", "#FFFF33", "#FFFF33"]);
                const styleSpeedFun = function (f) {
                    const sp = f.get('speed_kmh')
                    const t = (sp - 5) / 180
                    const color = colorScaleSpeed(t)
                    return new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: color,
                            width: 1.5
                        })
                    });
                }

                //date style
                const colorScaleDate = d3.scaleLinear().domain([0, 0.5, 1]).range(["#377EB8", "#FFFF33", "#E41A1C"]);
                const styleDateFun = function (f) {
                    const ymin = 39.6, ymax = 51
                    const timestamp = f.get('start_time')
                    const date = new Date(timestamp);
                    const years = date.getTime() / 31557600000;
                    const t = (years - ymin) / (ymax - ymin)
                    const color = colorScaleDate(t)

                    return new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: color,
                            width: 1.5
                        })
                    });
                }

                //create vector layer
                var vectorSource = new ol.source.Vector();
                var vectorLayer = new ol.layer.Vector({
                    source: vectorSource,
                    style: f => {
                        const selectedStyle = document.querySelector('input[name="style"]:checked').value
                        if (selectedStyle == "byspeed") return styleSpeedFun(f)
                        if (selectedStyle == "bydate") return styleDateFun(f)
                        return styleDefaultFun(f)
                    }
                });
                map.addLayer(vectorLayer);






                //tile cache
                const cache = {}
                function getCacheData(z, x, y) {
                    if (!cache[z]) return
                    if (!cache[z][x]) return
                    return cache[z][x][y]
                }
                function insertInCache(z, x, y, data) {
                    if (!cache[z]) cache[z] = {}
                    if (!cache[z][x]) cache[z][x] = {}
                    cache[z][x][y] = data
                }


                //read base metadata
                const ts0 = metadata.tile_size_0, r0 = metadata.resolution_0,
                    ox = metadata.origin_x, oy = metadata.origin_y,
                    z_min = metadata.z_min, z_max = metadata.z_max

                //transform geojson geometry coordinate from tile CRS to map CRS
                function transformGeoJSONGeometryCoordinates(geometry, tile, ts, r) {
                    function transformCoordinates(coordinates) {
                        if (Array.isArray(coordinates[0])) return coordinates.map(transformCoordinates);
                        else {
                            const x = coordinates[0], y = coordinates[1]
                            return [ox + tile.x * ts + x * r, oy + tile.y * ts + y * r];
                        }
                    }
                    //if (geometry && geometry.coordinates)
                    geometry.coordinates = transformCoordinates(geometry.coordinates);
                }


                function updateLayer() {

                    //get zoom level
                    let z = Math.round(map.getView().getZoom())
                    //console.log(z)
                    if (z < z_min) z = z_min; else if (z > z_max) z = z_max

                    //compute tile size and resolution
                    const ddd = Math.pow(2, z)
                    const ts = ts0 / ddd
                    const r = r0 / ddd

                    //clear
                    vectorSource.clear();

                    //get tiles within viewshed
                    var bbox = map.getView().calculateExtent(map.getSize());
                    var tiles = getTiles(bbox, ts);

                    //handle each tile
                    tiles.forEach(tile => {

                        //try to retrieve from cache
                        const features = getCacheData(z, tile.x, tile.y)

                        if (features == "failed" || features == "loading") {
                            //do nothing
                        } else if (features) {
                            //add cached features to layer
                            vectorSource.addFeatures(features);
                        } else {
                            //mark as loading
                            insertInCache(z, tile.x, tile.y, "loading")

                            //launch request
                            fetch(`http://127.0.0.1:5500/tiled/${z}/${tile.x}/${tile.y}.geojson`)
                                .then(response => response.json())
                                .then(geojson => {

                                    //apply coordinates transformation to features
                                    geojson.features.forEach(feature => transformGeoJSONGeometryCoordinates(feature.geometry, tile, ts, r));
                                    geojson.features.forEach(feature => feature.id = Math.round(1e15 * Math.random()))

                                    //transform into OL feature
                                    var features = new ol.format.GeoJSON().readFeatures(geojson, { featureProjection: 'EPSG:3857' });

                                    //store into cache
                                    insertInCache(z, tile.x, tile.y, features)

                                    //add features to layer
                                    vectorSource.addFeatures(features);
                                })
                                .catch(error => {
                                    insertInCache(z, tile.x, tile.y, "failed")
                                    //console.error('Error fetching GeoJSON tile:', tile.x, tile.y, error)
                                });
                        }
                    });
                }

                //get tiles intersecting the viewshed
                function getTiles(bbox, ts) {

                    const [xmin, ymin, xmax, ymax] = bbox;

                    const
                        xtmin = Math.floor((xmin - ox) / ts),
                        ytmin = Math.floor((ymin - oy) / ts),
                        xtmax = Math.floor((xmax - ox) / ts),
                        ytmax = Math.floor((ymax - oy) / ts);

                    var tiles = [];
                    for (var xt = xtmin; xt <= xtmax; xt++)
                        for (var yt = ytmin; yt <= ytmax; yt++)
                            tiles.push({ x: xt, y: yt });

                    return tiles;
                }

                //trigger layer refresh on viewshed changes
                map.getView().on('change:center', updateLayer);
                map.getView().on('change:resolution', updateLayer);

                updateLayer();

            })
            .catch(error => console.error('Error fetching the JSON data:', error));
    </script>
</body>

</html>